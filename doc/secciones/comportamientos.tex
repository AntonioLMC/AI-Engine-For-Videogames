%--------------------------------------------------------------------
\medskip
\section{Comportamientos}
Todo lo referente a esta sección, se encuentra dentro del paquete \texttt{com.mygdx.iadevproject.aiReactive.behaviour} del proyecto. Para generalizar el uso de los comportamientos, se ha decidido crear la interfaz \texttt{Behaviour} que tienen que implementar todos los distintos tipos de comportamientos. Esta interfaz proporciona un solo método:
\begin{itemize}
 \item \texttt{getSteering()}, que no recibe ningún parámetro y devuelve un \texttt{Steering}. Este método no recibe ningún parámetro para generalizar los comportamientos, pues no todos los comportamientos necesitan lo mismo para poder calcular su steering. De esta manera, en la creación del comportamiento concreto, se ha de proporcionar todos los datos necesarios para que él pueda calcular su steering, implementando a su manera, este método. 
\end{itemize}

A continuación, en las siguientes subsecciones se muestran todos los comportamientos que hemos implementado.

%--------------------------------------------------------------------
\medskip
\subsection{Comportamientos no acelerados}
Todo lo referente a esta sección, se encuentra dentro del paquete \\ \texttt{com.mygdx.iadevproject.aiReactive.behaviour.noAcceleratedUnifMov} del proyecto. Los distintos comportamientos no acelerados que hemos implementado son:
\begin{itemize}
 \item \texttt{Arrive\_NoAccelerated}. Este comportamiento consiste en llegar hacia un objetivo, rodeado por un radio de satisfacción en el que se supone que el personaje ya ha llegado, a la máxima velocidad y en un tiempo determinado. Así, para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
  \item El personaje que va a aplicar el comportamiento.
  \item El objetivo al que se quiere dirigir.
  \item La máxima velocidad con la que se aplica el comportamiento.
  \item El radio de satisfacción.
  \item El tiempo que se tarda en llegar al objetivo.
 \end{itemize}
 
 \item \texttt{Flee\_NoAccelerated}. Este comportamiento consiste en alejarse de un determinado objetivo, a la máxima velocidad. Para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
  \item El personaje que va a aplicar el comportamiento.
  \item El objetivo del que se quiere alejar.
  \item La máxima velocidad con la que se aplica el comportamiento.
 \end{itemize}
 
 \item \texttt{Seek\_NoAccelerated}. Este comportamiento es el opuesto al anterior, consiste en ir hacia un determinado objetivo, a la máxima velocidad. Los parámetros son los mismos que los necesarios en el anterior. 
 
 \item \texttt{Wander\_NoAccelerated}. Este comportamiento consiste en moverse de manera aleatoria, con un ángulo máximo de rotación a la máxima velocidad. Para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
  \item El personaje que va a aplicar el comportamiento.
  \item La máxima velocidad con la que se aplica el comportamiento.
  \item El máximo ángulo de rotación que puede cambiar un personaje su orientación.
 \end{itemize}
\end{itemize}

Es importante destacar, que estos cuatro comportamientos, dentro del método \texttt{getSteering()} modifican la orientación del personaje.


%--------------------------------------------------------------------
\medskip
\subsection{Comportamientos acelerados}
Todo lo referente a esta sección, se encuentra dentro del paquete \\ \texttt{com.mygdx.iadevproject.aiReactive.behaviour.acceleratedUnifMov} del proyecto. Los distintos comportamientos acelerados que hemos implementado son:
\begin{itemize}
 \item \texttt{Align\_Accelerated}. Este comportamiento consiste en adoptar la misma orientación que otro personaje (personaje destino) mediante un movimiento giratorio. La condición principal para llevar a cabo dicho movimiento es que debemos girar hacía el lado cuyo ángulo hacia la orientación destino sea menor. Además, en función de lo cerca que esté la fuente del destino (del valor del ángulo diferencia), la fuente se comportará del manera distinta. Hasta llegar a un ángulo exterior, la fuente gira con la máxima velocidad angular permitida. Al superar dicho ángulo, el personaje va adaptando su velocidad angular. Cuando se supera un ángulo interior, se devuelve un steering con aceleración lineal nulo y con aceleración angular inversa a la velocidad angular del personaje fuente. Para crear este comportamiento son necesarios los siguientes parámetro:
 \begin{itemize}
 	\item Personaje origen y \texttt{WorldObject} destino.
 	\item Máxima aceleración angular que el personaje puede aplicar.
 	\item Máxima rotación (velocidad angular) que el personaje puede aplicar.
 	\item \texttt{targetRadious} del personaje destino (ángulo interior). En este comportamiento no es un radio, sino un ángulo.
 	\item \texttt{slowRadious} del personaje destino (ángulo exterior). En este comportamiento no es un radio, sino un ángulo.
 	\item \texttt{timeToTarget} es el tiempo que queremos que tarde el personaje en realizar este comportamiento.
 \end{itemize}
 \item \texttt{AntiAlign\_Accelerated}. Este comportamiento consiste en adoptar la orientación opuesta de un personaje destino mediante un movimiento giratorio. Al igual que antes, debemos girar hacía el lado cuyo ángulo hacia la orientación deseada sea menor. El funcionamiento del comportamiento es igual que el anterior (aunque en este caso, debemos posicionarnos con orientación inversa a la del destino). Para crear este comportamiento son necesarios los mismos parámetros que el comportamiento anterior.
 \item \texttt{Arrive\_Accelerated}. En este comportamiento se definen 3 zonas distintas en las que el comportamiento del personaje es distinto. Podemos encontrar 2 radios ficticios con respecto al personaje destino. En primer lugar, el personaje fuente va aplicando la máxima aceleración establecida hasta llegar al radio exterior. Al llegar al radio exterior, el personaje adapta su velocidad en función de la distancia entre el personaje destino y él, hasta llegar al radio interior. Finalmente, cuando el personaje esta en el radio interior, este comportamiento devuelve el steering nulo (con valor 0). Para crear este comportamiento son necesarios los siguientes parámetro:
 \begin{itemize}
 	\item Personaje origen y \texttt{WorldObject} destino.
 	\item El valor de la máxima aceleración permitida.
 	\item El valor de la máxima velocidad permitida.
 	\item \texttt{targetRadious}. El radio de la circunferencia ficticia interior.
 	\item \texttt{slowRadious}. El radio de la circunferencia ficticia exterior.
 	\item \texttt{timeToTarget} es el tiempo que queremos que tarde el personaje en realizar este comportamiento.
 \end{itemize}
 \item \texttt{Arrive\_Accelerated\_WithOneRadius}. Este comportamiento es una mezcla entre un Seek y un Arrive (hereda del comportamiento Seek Acelerado). En este comportamiento podemos encontrar solamente un radio ficticio alrededor del personaje destino. La fuente se mueve aplicando un comportamiento Seek Acelerado normal hasta llegar al radio y cuando entra en él empieza a frenar (devolviendo un steering cuyo vector aceleración tiene un sentido contrario al vector velocidad del personaje fuente). A parte de los parámetros del padre (comportamiento Seek), también son necesarios los siguientes parámetros:
 \begin{itemize}
 	\item \texttt{targetRadious}. El radio de la circunferencia ficticia.
 \end{itemize}
 \item \texttt{Flee\_Accelerated}. Cuando un personaje aplica este comportamiento, se aleja del personaje destino aplicando la máxima aceleración establecida. Para crear este comportamiento son necesarios los siguientes parámetro:
 \begin{itemize}
 	\item El personaje que va a aplicar el comportamiento.
  	\item El objetivo al que se quiere dirigir.
  	\item La máxima aceleración con la que se aplica el comportamiento.
 \end{itemize} 
 \item \texttt{Seek\_Accelerated}. Este comportamiento consiste en ir hacia un punto objetivo a la máxima aceleración posible. Para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
  \item El personaje que va a aplicar el comportamiento.
  \item El objetivo al que se quiere dirigir.
  \item La máxima aceleración con la que se aplica el comportamiento.
 \end{itemize}
 Para este comportamiento, se ha hecho uso de las dos implementaciones que nos han proporcionado los profesores en la teoría: la implementación de Millington y la implementación de Reynolds. De esta manera, por defecto, se utiliza la implementación de Millington, pero si se quiere cambiar de implementación, proporciona el método \texttt{setMode()} que recibe como parámetro el modo al que se quiere cambiar. El valor del modo de cada una de las implementaciónes está en las constantes \texttt{SEEK\_ACCELERATED\_MILLINGTON} y \texttt{SEEK\_ACCELERATED\_REYNOLDS} correspondientemente.
 
 
 \item \texttt{VelocityMatching\_Accelerated}. Este comportamiento consiste en, dado un objetivo, ponerse a la misma velocidad que él. Para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
  \item El personaje que va a aplicar el comportamiento.
  \item El objetivo al que se quiere ajustar a su velocidad.
  \item La máxima aceleración a la que se puede aplicar el comportamiento.
  \item El tiempo que en que se alcanza la velocidad del objetivo.
 \end{itemize}
 Este comportamiento, es uno de los comportamientos que puede mostrar las líneas de debug para visualizar su correcto funcionamiento. 
\end{itemize}

%--------------------------------------------------------------------
\medskip
\subsection{Comportamientos delegados}
Todo lo referente a esta sección, se encuentra dentro del paquete \\ \texttt{com.mygdx.iadevproject.aiReactive.behaviour.delegated} del proyecto. Los distintos comportamientos delegados que hemos implementado son:
\begin{itemize}
 \item \texttt{CollisionAvoidance}. Este comportamiento consiste en evitar colisiones con otros objetos. Este comportamiento supone que todos los objetivos, así como el personaje, están protegidos por un círculo que los envuelve y detecta colisión cuando el círculo del personaje interseca con alguno de los círculos de los objetivos. Para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
  \item El personaje que va a aplicar el comportamiento.
  \item La lista de objetivos a evitar.
  \item La máxima acceleración que se aplica para evitar el choque.
 \end{itemize}
 Para evitar las colisiones, el comportamiento tiene en cuenta tanto la velocidad del personaje como la velocidad de todos los objetivos, y con ella calcula si en un futuro van a chocar. De todos los objetivos con los que pueda chocar, se queda con el que esté más cercano; es decir, con el que va a chocar antes. Una vez que lo ha calculado, entonces hace uso del comportamiento \texttt{Evade} para evitar chocar con el objetivo obtenido. 
 
 Este comportamiento, es uno de los comportamientos que puede mostrar las líneas de debug para visualizar su correcto funcionamiento. 
 
 \item \texttt{Persue}. Este comportamiento, al igual que el Seek, se aplica para ir hacia/perseguir a otro personaje (personaje destino). La diferencia con respecto al comportamiento Seek es que en este caso no vamos hacia el propio personaje destino, sino hacia \textbf{una predicción} de dónde estará el personaje destino pasado un tiempo. Por tanto, en primer lugar, se realiza dicha predicción y, a continuación, llamamos al comportamiento padre estableciendo como objetivo un personaje ficticio con la posición predicha (en vez del propio personaje real). El único parámetro adicional necesario para crear este comportamiento es \texttt{maxPrediction}, que define el tiempo máximo en segundos para predecir la posición del personaje destino.
  
 \item \texttt{Evade}. Este comportamiento, al igual que el Flee, se aplica para huir/escapar de otro personaje (personaje destino). La diferencia con respecto al comportamiento Flee es que en este caso no escapamos del propio personaje destino, sino de \textbf{una predicción} de dónde estará el personaje destino pasado un tiempo. El funcionamiento y parámetros son los mismos que el comportamiento anterior.
 
 \item \texttt{Face}. Este comportamiento consiste hacer que el personaje se quede mirando hacia un objetivo. Es un tipo de \texttt{Align\_Accelerated}, por lo que recibe los mismos parámetros que éste. Sin embargo, a diferencia del Align, este comportamiento utiliza el objetivo que se le pasa como parámetro para saber la posición en la que se encuentra y así, poder calcular la orientación a la que se tiene que alinear el personaje.
 
 \item \texttt{LookingWhereYouGoing}. Este comportamiento consiste en cambiar la orientación del personaje para que mire hacia donde va; es decir, que mire en la dirección a la que se mueve. Es un tipo de \texttt{Align\_Accelerated} y para su creación, recibe los mismos parámetros que este, exceptuando el objetivo, pues este es calculado por el comportamiento. Su funcionamiento consiste en obtener la orientación del vector velocidad del personaje y alinearse con él.
 
 \item \texttt{PathFollowingWithoutPathOffset}. Este comportamiento consiste en seguir una serie de puntos aplicando un comportamiento Seek hacia cada uno de ellos (este comportamiento hereda de Seek Acelerado). Este comportamiento tiene 2 modos de funcionamiento: seguir la lista de puntos y para al final (\texttt{MODO\_PARAR\_AL\_FINAL}) o seguir la lista de puntos, volver a seguirla haciendo el camino inverso, volver a seguirla... y así hasta el infinito (MODO\_IDA\_Y\_VUELTA). Para poder llevar a cabo este segundo modo, los punto de la lista de entrada no pueden eliminarse sin más, sino que debemos de tener otra lista en la que vayamos almacenando aquellos puntos por los que ya hemos pasado. A la hora de comprobar si se ha alcanzado un punto, no se comparará si la posición actual del personaje es exactamente igual a la posición del punto, sino que existe un margen que viene definido por el parámetro \texttt{radius} (es decir, un personaje ha llegado a un punto si está dentro del círculo cuyo radio viene definido por el valor de dicho parámetro). A la hora de aplicar el Seek a cada uno de los puntos de la lista de entrada, se crea un personaje ficticio cuya posición en el punto al que debemos ir. Para la creación de este comportamiento, son necesarios los siguientes parámetros (además de los necesarios para el \texttt{Seek\_Accelerated}):
 \begin{itemize}
 	\item La lista de puntos por los que el personaje debe pasar.
 	\item \texttt{radius}. El radio de \textit{satisfacción} o \textit{permisividad}.
 	\item El modo de funcionamiento del comportamiento.
 \end{itemize}
 
 \item \texttt{PathFollowingWithoutPathOffset\_Arrive}. Este comportamiento funciona exactamente igual que el anterior, excepto que en este caso hereda del Arrive en vez de del Seek. La única diferencia relevante a tener en cuenta es que en el comportamiento anterior teníamos un atributo llamado \texttt{radius}. En este caso no lo tenemos, puesto que ese radio será el \texttt{targetRadious} del padre (del Arrive). En cuanto a los parámetros, no introduce nada nuevo con respecto a los parámetro propios del comportamiento \texttt{Arrive} acelerado y a la lista de puntos y el modo (que también estaban presentes en el otro PathFollowing).
 
 \item \texttt{WallAvoidance}. Este comportamiento consiste en evitar colisiones con otros objetos. La diferencia entre este comportamiento y el anterior, es que la colisión no se detecta cuando el círculo que envuelve al personaje interseca con el círculo de alguno de los objetivos, sino que desde el personaje se lanzan tres rayos (separados un ángulo y longitud determinada), donde el rayo central sigue la dirección de la velocidad del personaje, y si alguno de esos rayos interseca con algún objetivo, entonces lo evita. Es un tipo de \texttt{Seek\_Accelerated}, por lo que recibe los mismos parámetros que él, exceptuando el objetivo, pues este es calculado por el comportamiento. Para la creación de este comportamiento, son necesarios los siguientes parámetros (además de los necesarios para el \texttt{Seek\_Accelerated}):
 \begin{itemize}
  \item La lista de objetivos a evitar.
  \item La distancia mínima de separación al objetivo. Debe ser mayor que el radio del círculo que envuelve el personaje.
  \item El ángulo de separación entre el rayo central y los laterales.
  \item La longitud del rayo central. Por defecto, se establece la longitud de los rayos laterales como el 75\% de la longitud del central. Si se quiere modificar esto, tiene otro constructor con el que se puede indicar la longitud de los rayos laterales de manera independiente.
 \end{itemize}
 Para detectar las colisiones entre los rayos y los objetos, se hace uso de la clase \texttt{Ray} y el método estático \texttt{intersectRaySphere()} proporcionado por la clase \texttt{Intersector}, que además de indicar si hay colisión, devuelve el punto de intersección en el caso de que haya una colisión. En el caso de que haya varios rayos que intersequen con el mismo objetivo, se obtiene aquella intersección que esté más próxima al personaje. Así, una vez que se tiene el punto de intersección, y teniendo en cuenta que suponemos que todos los objetos están envueltos por un círculo, el cálculo de la normal en el punto de intersección es inmediato. Tras tener la normal, calculamos el punto al que realizar el Seek y delegamos en él para mover el personaje hacia esa posición.
 
 Es importante destacar, que previo a la comprobación de la intersección, se obtiene de la lista de objetivos a evitar, aquél objetivo que esté más cerca del personaje. De tal manera, que no se hace la comprobación de la intersección para todos los objetivos, si no solamente para el objetivo más cercano. 
 
 Este comportamiento, es uno de los comportamientos que puede mostrar las líneas de debug para visualizar su correcto funcionamiento. 

 
 \item \texttt{Wander\_Delegated}. Este comportamiento consiste en moverse de manera aleatoria, igual que el \texttt{Wander\_NoAccelerated} pero de manera acelerada, lo que proporciona un movimiento mucho más suave. Es un tipo de \texttt{Face}, por lo que recibe los mismos parámetros que este, exceptuando el objetivo, pues este se calcula dentro del comportamiento. Para la creación de este comportamiento, son necesarios los siguientes parámetros, además de los necesarios para el \texttt{Face}:
 \begin{itemize}
  \item La distancia desde el personaje al Facing.
  \item El radio del círculo del Facing.
  \item El máximo ángulo que el personaje puede girar.
  \item La orientación del personaje de la que se parte.
  \item La máxima acceleración a la que se va a mover el personaje.
 \end{itemize}
 Este comportamiento, es uno de los comportamientos que puede mostrar las líneas de debug para visualizar su correcto funcionamiento. 

\end{itemize}

%--------------------------------------------------------------------
\medskip
\subsection{Comportamientos de grupo}
Todo lo referente a esta sección, se encuentra dentro del paquete \\ \texttt{com.mygdx.iadevproject.aiReactive.behaviour.group} del proyecto. Los distintos comportamientos de grupo que hemos implementado son:
\begin{itemize}
 \item \texttt{Cohesion}. Este comportamiento consiste en movernos hacia el centro de masas de un conjunto de objetivos con una aceleración máxima (este comportamiento hereda del Seek Acelerado). Solamente se tendrán en cuenta aquellos objetos que estén dentro de un radio (atributo \texttt{threshold}). A parte de los parámetros necesarios para el Seek, se necesitan los siguientes parámetro:
 \begin{itemize}
 	\item La lista de objetivos a tener en cuenta para calcular el centro de masas (solo se tendrán en cuenta aquellos que estén dentro del radio establecido).
 	\item \texttt{threshold}. Radio dentro del cual un elemento de la lista de objetivos se tendrá en cuenta.
 \end{itemize}
 \item \texttt{Separation}. Este comportamiento consiste en alejarnos de un conjunto de objetivos aplicando una fuerza de repulsión y con una aceleración máxima establecida. Al igual que antes, solamente se tendrán en cuenta aquellas objetivos que estén dentro de un radio (atributo \texttt{threshold}). El vector aceleración lineal final se calculará teniendo en cuenta cada una de las repulsiones calculadas con respecto a cada uno de los elementos que se encuentren dentro del radio establecido. Cabe destacar que este comportamiento \textbf{no se ha implementado exactamente como en las transparencias}. Según las transparencias, cada uno de los vectores individuales se deben ir añadiendo al resultado final, sin embargo, esto no nos funcionó (el personaje fuente pasaba de largo sin sufrir ningún tipo de repulsión). Lo que hemos hecho es ir añadiendo \textbf{cada vector, pero con sentido contrario} al resultado final. De esta manera sí conseguimos que el behavior haga lo que tiene que hacer. Para la creación de este comportamiento, son necesarios los siguientes parámetros:
 \begin{itemize}
 	\item Personaje origen y la lista de objetivos (tipo \texttt{WorldObject}).
 	\item \texttt{threshold}. Radio dentro del cual un elemento de la lista de objetivos se tendrá en cuenta.
 	\item \texttt{decayCoefficient}. Fuerza de repulsión.
 	\item \texttt{maxAcceleration}. Máxima aceleración establecida.
 \end{itemize}
\end{itemize}

